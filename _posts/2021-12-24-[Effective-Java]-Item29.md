---
layout: post
title: "[Effective Java] Item29. 이왕이면 제네릭 타입으로 만들라"
description: 배열을 제네릭 방식으로 바꾸는 두 가지 방법
categories: self
---

> 아이템 29. 이왕이면 제네릭 타입으로 만들라

-----

Author: seovalue

만약, 우리가 컬렉션 객체를 커스텀하게 제공하는 경우가 있다고 가정하자.<br>
이러한 경우에는 직접 형변환을 해야하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.<br>
따라서, 새로운 타입을 설계할 때에는 **제네릭**을 활용하자.<br>

이 책의 해당 파트에서는 `Object[]`를 활용한 Stack을 제네릭을 활용한 스택으로 변경해가는 과정을 보여준다.<br>
배열을 활용하게 되면 앞선 item들에서 다뤘던 것처럼 공변성이 존재해서 런타임에 타입 안전하지 않다.<br>
따라서, 내부적으로 제네릭을 활용하도록 하고, 배열을 꼬옥 활용해야할 경우에는 아래 PK가 자세히 적어준 대로 제약을 우회하거나 `@SuppressWarning` 어노테이션을 통해 비검사 경고를 제거할 수 있도록 타입 안전하게 설계해야한다.<br>


-----

Author: PK

실체화 불가능한 타입으로는 배열을 만들 수 없다.<br>
배열이 있는 코드를 제네릭으로 바꾸려고 할 때 이 사실 때문에 고민이 생길 것이다.<br>
이에 대한 해결책은 두 가지다:
1. 제네릭 배열 생성을 금지하는 제약을 대놓고 우회한다.
2. E[] 배열을 Object[] 타입으로 바꾼다.

### 1. 제네릭 배열 생성을 금지하는 제약을 대놓고 우회한다.
```java
return (E[]) new Object[1];
```
컴파일러가 제 할 일을 하겠지만, 경고는 나타낸다. 하지만 비검사 형변환이 안전하다는 확인이 있으면
애너테이션을 활용해서 경고를 무시할 수 있다.<br>

장점:
* 가독성이 좋다.
* 코드가 더 짧다. 두 번째 방식은 배열에서 원소를 읽을 때마다 형변환을 해줘야 한다.
* 현업에서는 해당 방식을 선호한다.

### 2. E[] 배열을 Object[] 타입으로 바꾼다.
```java
E result = (E) elements[--size];
```
E 는 실체화 불가능한 타입이라서 컴파일러가 런타임에 이뤄지는 형변환이 안전한지 알 방법이 없다.
그래서 이 역시 형변환이 안전한지 확신을 가졌을 때 사용하고, 애너테이션을 활용해서 경고를 무시해야 한다.

장점:
* 첫 번째 방식은 E 가 Object 가 아닌 한 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염을 일으킨다.
