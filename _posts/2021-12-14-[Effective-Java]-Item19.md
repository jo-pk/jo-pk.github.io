---
layout: post
title: "[Effective Java] Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라"
description: 들어가며
categories: self
---

Author: seovalue

> 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

상속용 클래스를 설계하는 경우에는 클래스 내부에서 스스로를 어떻게 사용하는 지 모두 문서로 남겨야한다. 또한 상속을 허용하는 경우 효율 좋은 하위 클래스를 만들 수 있도록 몇가지 메서드를 protected로 제공해야한다. 

-----

Author: PK

*상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.*<br>
이 말을 듣자마자 떠오르는 것이 있다. 그렇다. 캡슐화가 바로 깨져버리는 것이다.
여태껏 은닉하고 캡슐화하고 웬만하면 모든 컴포넌트에 private 처리를 하자고 강조에 강조를 했는데,
상속을 쓰려면 내 손으로 '캡슐화를 깨트리고 있는 중입니다'라며 문서를 남겨야한다...<br>

만약 그러지 않는다면 클래스에 final 처리를 하라고 저자는 말한다.<br>
맞는 말이다. final 처리를 하면 해당 클래스는 더 이상 상속할 수 없다.<br>

API 문서의 메서드 설명 끝에 **Implementation Requirements** 로 시작하는 절을 볼 수 있다.<br>
이는 메서드의 내부 동작 방식을 설명하는 곳이다. 명심하자.<br>
메서드 주석에 `@implSpec` 태그를 붙여주면 javadoc 이 생성해준다.<br>
참고로 `-tag "impleSpec:a:Implementation Requirements:"`를 커맨드라인에 추가해서 이 태그를 필수화 할 수 있다.<br>

이렇듯, 상속할 수 있는 클래스를 "잘" 만들기란 매우 어렵다.
상속용 클래스에서 어떤 메서드를 protected 로 노출하고, 잘 만들었는지 테스트하는 방법은
결국 직접 하위 클래스를 만들어서 경험해보는 것이 **유일하다.**
저자 말로는 경험상 하위 클래스 3개 정도는 작성해봐야하며, 그 중 하나 이상은 제 3자가 작성해야한다.<br>

저자는 상속을 사용했을 때의 복잡성을 매우 강조하면서, 상속을 허용하는 클래스가 지켜야 할 제약사항을 알려준다:
* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
* clone 과 readObject 메서드는 생성자와 비슷한 효과를 내기 때문에 이 역시 재정의 가능한 메서드를 호출해서는 안된다.

Cloneable과 Serializable 인터페이스를 구현한 클래스는 웬만해서는 상속하지 않는 것이 좋다.
**readObject 의 경우는 하위 클래스가 미처 다 역직렬화되지 전에 재정의한 메서드부터 호출하게 된다.**
**clone 의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다.**
모두 다 오작동으로 이어지는 방식이다.<br>

만약 표준 인터페이스를 구현하지 않은 구현체를 상속하고 싶다면 클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고, 이를 문서화 하면 된다. 이 경우엔 메서드를 재정의해도 다른 메서드의 동작에 영향을 주지 않는다.
