---
layout: post
title: "[Effective Java] Item17. 변경 가능성을 최소화하라"
description: 하지만 Entity라면...?
categories: self
---

Author: seovalue

> 아이템 17. 변경 가능성을 최소화하라.

### 클래스를 불변으로 만들기 위한 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

### 불변 객체의 장점
1. 불변 객체는 thread-safe하며 따로 동기화할 필요 없다.
2. 불변 객체는 따라서 안심하고 공유할 수 있다.
3. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 불변식을 유지하기 쉽기에 장점이 많다.
4. 불변 객체는 그 자체로 실패 원자성을 제공한다.

### 불변 객체의 단점
값이 다르면 반드시 독립된 객체로 만들어야한다.
따라서 원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 발생할 수 있다.

이런 경우에는 불변 객체와 가변 동반 클래스를 함께 둘 수 있다. 예를 들자면 String과 StringBuilder가 있을 것이다.

-----

Author: PK

불변 클래스란 그 인스턴스가 소멸될 때까지 상태가 변경되지 않는 것을 말한다.<br>
불변 클래스는 오류가 생길 위험이 적어서 안전하다.<br>
클래스를 불변으로 만드는 방법은 위에 조앤이 친절하게 적어줘서 따로 적지 않겠다.<br>

그런데 저 방법 중 4번과 5번이 좀 특이했다.<br>
4번은 '모든 필드를 final로 선언한다'. 
추가 설명으로 *필드를 public final로만 선언해도 불변 객체가 되지만, 
이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권장하지는 않는다*라 적혀있다.
즉, 필수는 아닌셈.<br>
5번은 만약 가변 필드가 있다면 인스턴스 그 자체 외에는 접근 못하도록 유지하라는 것이다.
그리고 해당 필드를 외부로 제공하려면 방어적 복사를 수행하라고 한다.
그렇다면 방어적 복사 처리를 하면 가변 인자가 있어도 불변객체라 불러도 괜찮은건가?<br>

아니라고 생각한다. 불변객체는 상태 변경이 필요할 때 새로운 객체를 반환한다.
책에는 흥미로운 설명이 있는데, 바로 이와 같은 이유로 메서드 이름을 동사(ex: add) 대신
전치사(ex: plus)를 사용한다는 것이다. `BigDecimal`과 같은 클래스는 불변 객체임에도
이 명명법을 따르지 않아서 잘못 사용되는 경우가 많다. (메서드의 이름이 이렇게 중요하다.)

