---
layout: post
title: "[Effective Java] Item24. 멤버 클래스는 되도록 static으로 만들어라"
description: 그리고 멤버 클래스의 네 가지 종류
categories: self
---

Author: seovalue

> 아이템 24. 멤버 클래스는 되도록 static으로 만들어라.

멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않으면 정적으로 만들자. 

-----

Author: PK

다른 클래스 안에서 정의된 클래스를 중첩 클래스(nested class)라 한다.<br>
당연하게도, 이러한 중첩 클래스는 자신을 감싼 클래스에서만 쓰여야 한다.<br>

중첩 클래스에는 네 가지 종류가 있다:
1. 정적 멤버 클래스
2. 비정적 멤버 클래스
3. 익명 클래스
4. 지역 클래스

#### 정적 멤버 클래스
* 바깥 클래스의 private 멤버에도 접근할 수 있다.
* 그 외엔 일반 클래스와 동일하다.
* public 도우미 클래스로 쓰인다. (ex: Calculator.Operation.PLUS 같은 형태로 원하는 연산 참조)

#### 멤버 클래스 (비정적)
* static 이 붙어있지 않다. (당연히)
* 정규화된 this 를 사용해 바깥 인스턴스의 메서드를 호출할 수 있다.
* 정규화된 this 를 사용해 바깥 인스턴스의 참조를 가져올 수 있다.
* 바깥 인스턴스 없이는 생성할 수 없다. 즉, 의존적이기 때문에 웬만하면 정적으로 만들어야 한다.
* 그래서 멤버 클래스는 생성 시간이 더 걸린다.
* 그럼에도 어뎁터를 정의할 때 자주 쓰인다.

**멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자**<br>
내 편리함을 떠나서, 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하면 메모리 누수가 발생하기도 한다.

##### 정규화된 this
`클래스명.this` 형태로 바깥 클래스의 이름을 명시하는 용법을 말한다.

#### 익명 클래스
* 이름이 없다.
* 코드 어디서든 만들 수 있고, 바깥 클래스의 인스턴스는 비정적인 문맥에서만 참조 가능하다.
* 제약이 많다.
  * 선언한 지점에서만 인스턴스 만들 수 있다.
  * instanceof 검사나 클래스 이름 활용한 로직을 수행할 수 없다.
  * 상위 타입에서 상속한 멤버 외에는 호출할 수 없다.
  * 가독성이 떨어진다.

람다 함수가 등장하기 전에는 작은 함수 객체나 처리 객체를 만들기 위해, 또는 정적 팩터리 메서드를 구현할 때 사용됐었다. 그러나 지금은 람다가 그 역할을 대신한다.

#### 지역 클래스
* 지역변수와 유효 범위가 같다.
* 이름이 있고, 반복적으로 사용할 수 있다.
* 비정적 문맥에서 사용될 때 바깥 인스턴스를 참조할 수 있다.
* 정적 멤버는 가질 수 없다.
* 네 개의 중첩 클래스 중 가장 드물게 사용된다.
